<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue3动态组件</title>
    <link href="/2022/07/20/%E5%89%8D%E7%AB%AF/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/07/20/%E5%89%8D%E7%AB%AF/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>Vue3双向绑定通常通过v-model语法糖实现，其实质是绑定了两个事件：</p><ul><li>组件外部修改值传入</li><li>组件内部修改值传出</li></ul><h2 id="通过-Render-创建双向绑定的元素"><a href="#通过-Render-创建双向绑定的元素" class="headerlink" title="通过 Render()创建双向绑定的元素"></a>通过 Render()创建双向绑定的元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref, createApp, h &#125; from &#x27;vue&#x27;<br><br>const data = ref(&quot;test&quot;)<br>const createDialog = (event: any) =&gt; &#123;<br>    var app = createApp(&#123;<br>        render() &#123;<br>            return h(<br>                Dialog,<br>                &#123;<br>                    modelValue: data.value,//绑定输入参数<br>                    onUpdate: (arg: any) =&gt; data.value = arg,//绑定修改事件<br>                    onClose:  () =&gt; app.unmount()//绑定销毁事件<br>                &#125;<br>            )<br>        &#125;<br>    &#125;)<br>    var box = document.getElementById(event.currentTarget.id + &quot;dialog&quot;)<br>    if (!box) &#123;<br>        box = document.createElement(&quot;div&quot;)<br>        box.style.top = event.pageY + &#x27;px&#x27;;<br>        box.style.left = event.pageX + &#x27;px&#x27;;<br>        box.classList.add(&#x27;tip-box&#x27;);<br>        box.id = event.currentTarget.id + &quot;dialog&quot;<br>        document.body.appendChild(box)<br>        // 让我们节点挂在到一个dom元素上<br>    &#125; else &#123;<br>        box.style.top = event.pageY + &#x27;px&#x27;;<br>        box.style.left = event.pageX + &#x27;px&#x27;;<br>        box.classList.add(&#x27;tip-box&#x27;);<br>        box.id = event.currentTarget.id + &quot;dialog&quot;<br>    &#125;<br>    app.mount(box)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="样例：dialog组件–子组件"><a href="#样例：dialog组件–子组件" class="headerlink" title="样例：dialog组件–子组件"></a>样例：dialog组件–子组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;el-card class=&quot;box-card&quot; shadow=&quot;hover&quot; v-if=&quot;doing&quot;&gt;<br>        &lt;el-alert title=&quot;Please be careful&quot; type=&quot;warning&quot; center show-icon style=&quot;margin-bottom: 10px;&quot; /&gt;<br>        &lt;el-input v-model=&quot;data&quot; placeholder=&quot;Please input&quot; /&gt;<br>        &lt;div class=&quot;button-group&quot;&gt;<br>            &lt;el-button type=&quot;info&quot; @click=&quot;cancle&quot;&gt;Cancel&lt;/el-button&gt;<br>            &lt;el-button type=&quot;primary&quot; @click=&quot;confirm&quot;&gt;Comfirm&lt;/el-button&gt;<br>        &lt;/div&gt;<br>    &lt;/el-card&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; defineProps, defineEmits, ref, watch &#125; from &#x27;vue&#x27;;<br>// 数据<br>const props = defineProps([&#x27;modelValue&#x27;])<br>const emit = defineEmits([&#x27;update&#x27;,&#x27;close&#x27;])<br>const data = ref(props.modelValue)<br>watch(<br>    () =&gt; data.value,<br>    (newValue: any, oldValue: any) =&gt; &#123;<br>        console.log(&quot;update=&gt;&quot;, newValue)<br>        emit(&#x27;update&#x27;, newValue)<br>    &#125;<br>)<br>// 处理<br>const doing = ref(true)<br>watch(<br>    () =&gt; doing.value,<br>    (newValue: any, oldValue: any) =&gt; &#123;<br>        console.log(&quot;close&quot;)<br>        emit(&#x27;close&#x27;)<br>    &#125;<br>)<br>const cancle = () =&gt; &#123;<br>    // TODO 销毁自身！<br>    doing.value = false<br>&#125;<br>const confirm = () =&gt; &#123;<br>    doing.value = false<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.box-card &#123;<br>    width: 100%;<br>    height: 100%<br>&#125;<br><br>.button-group &#123;<br>    margin-top: 10px;<br>    display: flex;<br>    justify-content: center;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础</title>
    <link href="/2022/06/28/C++/C++/"/>
    <url>/2022/06/28/C++/C++/</url>
    
    <content type="html"><![CDATA[<h1 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h1><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>强调算法过程。</p><ul><li>自顶向下</li><li>结构化编程</li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>强调数据处理，通过设计与问题本质特性相对应的数据结构，让语言来满足问题的要求，其本质是以建立反映现实世界中事物特征的模型体现出来的抽象思维过程和面向对象的方法。</p><ul><li>继承</li><li>多态</li><li>封装</li></ul><h3 id="通用编程"><a href="#通用编程" class="headerlink" title="通用编程"></a>通用编程</h3><p>通过<strong>模板</strong>实现算法复用，强调算法的重用性。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h3 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//重构操作符：</span><br>cout &lt;&lt; xxx;<br><span class="hljs-comment">//函数调用：</span><br><span class="hljs-built_in">max</span>(a,b)<br></code></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol><li>赋值转换</li><li>表达式转换：转换提升，如整型提升等</li><li>函数原型控制的传参转换（也可以取消原型控制，但不建议如此）</li><li>强制类型转换</li></ol><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>数组形式和string类形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C风格：</span><br><span class="hljs-built_in">strlen</span>(字符数组);<span class="hljs-comment">//函数判断条件为第一个空字符终止，因此未被初始化的字符数组，长度结果不定！</span><br><span class="hljs-comment">//C++风格：</span><br>str1.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//符合常识的智能类，定义是无越界风险。</span><br></code></pre></td></tr></table></figure><p>整行输入控制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//cin.get()与cin.getline()的不同：</span><br>cin.<span class="hljs-built_in">get</span>();<span class="hljs-comment">//读取到换行符后，终止写入并保留换行符在输入缓存区，通常用作精细控制，如对输入终止情况的判断：过长 or 换行？</span><br>cin.<span class="hljs-built_in">getline</span>();<span class="hljs-comment">//舍弃换行符</span><br><br><span class="hljs-comment">//友元函数：</span><br><span class="hljs-built_in">getline</span>(cin,str1);<span class="hljs-comment">//从源写入str1，无越界风险。</span><br></code></pre></td></tr></table></figure><blockquote><p>cin.get(ch) 和 ch&#x3D;cin.get() 的区别：</p><p><img src="C:\Users\l2442\AppData\Roaming\Typora\typora-user-images\image-20220523235302630.png" alt="image-20220523235302630"></p></blockquote><p>循环输入控制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(cin.<span class="hljs-built_in">get</span>(ch)) <span class="hljs-comment">//cin读取成功则转换为true</span><br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li>整型</li><li>浮点型</li><li>布尔型</li></ol><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ol><li><p>数组</p><ul><li>延伸：string类</li></ul></li><li><p>结构</p></li><li><p>共用体</p><ul><li><p>基本语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">id</span><br>&#123;<br><span class="hljs-type">int</span> id_num;<br><span class="hljs-type">char</span> id_char[<span class="hljs-number">20</span>];<br>&#125;<br><span class="hljs-comment">//共用一个地址空间，空间大小取决于最大类型。</span><br><span class="hljs-comment">//同一时间只能存储一种类型值。</span><br><span class="hljs-comment">//常放于结构体中采用匿名形式定义。</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>枚举</p><ul><li><p>基本语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//定义</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123;red,yellow,green&#125;;<span class="hljs-comment">//不指定数值，默认从0开始递增赋值。</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123;red,yellow = <span class="hljs-number">0</span>,green&#125;;<span class="hljs-comment">//规则：可以出现重复的值，后面的值必须大于或等于前面的值。</span><br></code></pre></td></tr></table></figure></li><li><p>枚举量可以提升为 int ，但 int 不能自动转换为枚举类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">band = <span class="hljs-number">3</span>;<span class="hljs-comment">//×</span><br>band = <span class="hljs-built_in">color</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//通过强制类型转换可以实现int型赋值，且采用取值范围判定法。</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>指针</p><ul><li><p>基本语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//定义</span><br><span class="hljs-type">int</span>* p1,p2;<span class="hljs-comment">//×，此声明会创建一个int指针和一个int变量。</span><br><span class="hljs-type">int</span> *p1,*p2;<span class="hljs-comment">//对于每个指针变量都需要一个*。</span><br><br><span class="hljs-comment">//管理</span><br><span class="hljs-type">int</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-comment">//分配。</span><br><span class="hljs-keyword">delete</span> p1;<span class="hljs-comment">//删除，防止内存泄漏。</span><br><span class="hljs-type">int</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//动态数组。</span><br><span class="hljs-keyword">delete</span> [] p2;<span class="hljs-comment">//需要指明地址空间对象是数组。</span><br><span class="hljs-comment">//delte只能删除由new分配的内存空间（不是指针，因为同一内存可能有多个指针），对于NULL指针的操作是安全的。</span><br></code></pre></td></tr></table></figure></li><li><p>指针与数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//通常情况下，可以将指针和数组名的使用等同：</span><br>array[<span class="hljs-number">1</span>] = *(array + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>指针与字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// c-style 可能出现的问题-&gt;（建议使用c++-style string类型）</span><br><span class="hljs-type">char</span>* ps = <span class="hljs-string">&quot;nb&quot;</span><br>cin &lt;&lt; ps;<span class="hljs-comment">//一般输出的是指针指向的字符串，即nb。</span><br>cin &lt;&lt; (<span class="hljs-type">int</span>*)ps;<span class="hljs-comment">//此时才输出地址。</span><br><span class="hljs-type">char</span> food[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;test&quot;</span><span class="hljs-comment">//不建议使用赋值语句，易出现问题。</span><br><span class="hljs-built_in">strncpy</span>(food,<span class="hljs-string">&quot;testStr&quot;</span>,<span class="hljs-number">19</span>);food[<span class="hljs-number">19</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//建议使用strncpy()初始化，字符串过长时需手动添置空字符。</span><br><br><span class="hljs-comment">//加深理解：</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> months[<span class="hljs-number">12</span>] = ... <span class="hljs-comment">//第一个const防止被修改，第二个const确保数组中的指针指向不改变。</span><br></code></pre></td></tr></table></figure></li><li><p>指针与结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//区分结构名和指向结构的指针（things为一结构类型）</span><br>things goods = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//使用成员变量：goods.member</span><br>things* ptr = &amp;goods;<span class="hljs-comment">//使用成员变量：ptr-&gt;member 或 (*ptr).member</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><ol><li><p>自动存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> <span class="hljs-type">int</span> count;<br><br><span class="hljs-comment">// 寄存器声明--表面频繁使用的量，使用内存堆栈以外的方式存储，如CPU寄存器。</span><br><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> count;<br></code></pre></td></tr></table></figure></li><li><p>静态存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//3种链接类型：</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">//代码块外声明，链接性为内部的；C++标准不赞成在命名空间和全局域使用static，而用namespace。</span><br><span class="hljs-type">int</span> count; <span class="hljs-comment">//代码块外声明，链接性为外部的；其他文件要使用则需使用关键字 extern ;一个文件只能定义一个！</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">//代码块内声明，无链接性。</span><br>&#125;<br><br><span class="hljs-comment">//静态类型未初始化自动赋值为0。</span><br><span class="hljs-comment">//static只能由常量表达式初始化：int x = 0; static int y = x; 用变量进行初始化是非法的！ </span><br></code></pre></td></tr></table></figure></li><li><p>动态存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">//由于静态变量只能由常量表达式初始化，所以 new 只能用在函数中：</span><br><span class="hljs-type">int</span>* count; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>count = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    ...<br>    <span class="hljs-keyword">delete</span> count;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h1><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承类型：</p><ol><li>public</li><li>private</li><li>protected</li></ol><p>访问权限：</p><p><img src="https://img-blog.csdnimg.cn/3ac4ad0c8d23485e882f93f4c78184f7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aqG6am86IOh5p2o,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>函数由函数原型和函数定义组成：</p><ul><li><p>函数原型：描述函数接口，存在头文件中。</p><blockquote><p>支持参数类型的自动转换，前提是有意义且可能的转化。</p><p>通常用于编译阶段的原型化，即静态类型检查。</p></blockquote></li><li><p>函数定义：包含函数代码，存在库文件中。</p></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>基本语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> rats;<br><span class="hljs-type">int</span> &amp; rodents = rats; <span class="hljs-comment">//类似const，必须在引用声明时初始化，且不可修改。等同于int * const pt = &amp;rats;</span><br></code></pre></td></tr></table></figure><p>const 引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//应尽量使用const引用：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a,<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)</span></span>;<br><span class="hljs-comment">//正常情况下，引用参数不接收不符合类型或表达式，因为其实质是使用临时变量进行存储。</span><br><span class="hljs-comment">//但是，使用const允许创建临时变量，因为不涉及内容修改，即不违反引用的功能定义。</span><br><br><span class="hljs-comment">//结构上的应用：</span><br><span class="hljs-function"><span class="hljs-type">const</span> info&amp; <span class="hljs-title">clone</span><span class="hljs-params">(info&amp; preInfo)</span></span>; <span class="hljs-comment">//常使用const修饰返回引用，避免语义混乱。</span><br></code></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载解析规则：</p><ul><li>优先度：具体函数&gt;具体化&gt;模板</li><li>无法区分 func(int &amp; a) 和 func(int a)。</li><li>无法区分 func(const int* p) 和 func(int* p)。</li><li>以特征标（编译器内部通过名称修饰实现）为区分标志，如参数顺序、类型和数量。</li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//基本语法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Any&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(Any&amp; a, Any&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//显式实例化</span><br><span class="hljs-keyword">template</span> <span class="hljs-type">void</span> Swap &lt;<span class="hljs-keyword">typename</span>&gt; (Any&amp; a, Any&amp; b);<br><span class="hljs-comment">//显式具体化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(Any&amp; a, Any&amp; b)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li><p>当函数不希望对接收量进行修改时，可以使用const对形参进行修饰，仅表示函数内无法修改，实参无需为const常量。</p><blockquote><p>要尽量使用 const，因为使函数可以接收 const 也可以接收非 const。</p><p>类似的情况：int age &#x3D; 10; const int* pt &#x3D; &amp;age; 仅表示不能通过 pt 修改 age 变量。</p><p>只有非 const 数据地址才能赋值给非 const 指针，在参数上同理。</p></blockquote></li><li><p>通常对于数组形参数，会增加一个形参n（size）用于接收数据长度消息。</p></li><li><p>函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//正确原型：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">double</span> (*fp)(<span class="hljs-type">int</span>))</span></span>; <span class="hljs-comment">//*fp代替函数名，int为形参，double为返回类型。原型定义需保持一致才可接收。</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>顺序点：该点前的操作都必须全部完成才可继续执行下一步，如分号。</li><li>逗号操作符：优先级最低，表达式的值由最右侧值而定，如 i&#x3D;{1,2} 则 i&#x3D;2 。</li><li>任何表达式都可以作为循环的测试条件，其值通常视左侧值而定，如 i&#x3D;4 则测试条件值为 4，即 true。</li></ol><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><strong>入口循环–先测试后循环体</strong></p><ul><li>while</li><li>for</li></ul><p><strong>出口循环–先循环体后测试</strong></p><ul><li>do while</li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>typedef与#define</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//#define的使用会产生问题，而typedef不会：</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> intPointer int*</span><br>intPointer p1,p2; <span class="hljs-comment">//p1为int pointer，p2为int</span><br><span class="hljs-comment">//注意：两者都不会创建新类型</span><br></code></pre></td></tr></table></figure><h3 id="常量限定"><a href="#常量限定" class="headerlink" title="常量限定"></a>常量限定</h3><p>const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//通常全局变量的链接性为外部的，但const限定的全局变量的链接性是内部的。 </span><br></code></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-comment">//符号常量的唯二定义方式：</span><br>    <span class="hljs-keyword">enum</span> &#123;Len = <span class="hljs-number">30</span>&#125;; <span class="hljs-comment">// 所有的对象都不会包含枚举变量，因为仅作为符号名称使用。</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> Len = <span class="hljs-number">30</span>; <span class="hljs-comment">// 更推荐的符号名称定义方式--静态常量--只能存储整数或枚举类型！</span><br>...<br><span class="hljs-keyword">public</span>:<br>...<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//对于不会修改成员的函数，尽量都写上const，以满足const Person的情景需求。</span><br>&#125;<br><br><span class="hljs-comment">//使用</span><br><span class="hljs-function">Person <span class="hljs-title">person1</span> <span class="hljs-params">()</span> <span class="hljs-comment">//简洁形式的调用构造函数初始化</span></span><br><span class="hljs-function">Person persons[5] </span>= &#123; <span class="hljs-comment">//类对象数组初始化，必须要有默认构造函数才可创建类对象数组！</span><br>    <span class="hljs-built_in">Person</span>(...) <span class="hljs-comment">//实质是常见临时对象进行复制赋值，最开始必须调用默认构造函数初始化。</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>...<br><span class="hljs-type">int</span> m_age; <span class="hljs-comment">//通常使用m_age区分构造函数的参数名。</span><br><span class="hljs-keyword">public</span>:<br>..<span class="hljs-number">.1</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age); <span class="hljs-comment">//构造函数必须放置于public中。</span><br>    ~<span class="hljs-built_in">Person</span>() <span class="hljs-comment">//析构函数。</span><br>&#125;<br><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>&#123;<br>m_age = age;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><p><strong>基类</strong></p><p>对于基类，即便它不需要构造函数，也应该提供一个虚拟析构函数。</p><ol><li>共有继承</li><li>保护继承</li><li>私有继承</li></ol><blockquote><ul><li>has-a</li><li>is-implemented-as-a</li><li>uses-a</li><li>is-a：应该尽量使用该原则去创建类继承关系</li></ul></blockquote><h1 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h1><h2 id="指针篇"><a href="#指针篇" class="headerlink" title="指针篇"></a>指针篇</h2><h3 id="指针转换运算符"><a href="#指针转换运算符" class="headerlink" title="指针转换运算符"></a>指针转换运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const_cast</span> &lt;new_type&gt; (expression)<br><span class="hljs-keyword">static_cast</span> &lt;new_type&gt; (expression)<br><span class="hljs-keyword">reinterpret_cast</span> &lt;new_type&gt; (expression)<br><span class="hljs-keyword">dynamic_cast</span> &lt;new_type&gt; (expression)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++</title>
    <link href="/2022/06/28/C++/Effective%20C++/"/>
    <url>/2022/06/28/C++/Effective%20C++/</url>
    
    <content type="html"><![CDATA[<h1 id="基本习惯"><a href="#基本习惯" class="headerlink" title="基本习惯"></a>基本习惯</h1><ol><li><p>使用<code>const</code>或<code>enums</code>定义常量，减少<code>#defines</code>的使用</p></li><li><p>形似函数的宏，最好使用<code>inline</code>替换<code>#defines</code></p></li><li><p>尽可能使用const：成员函数、static对象等</p><ul><li><p><code>const</code>和<code>non-const</code>成员函数避免重复</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    ...<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[] (std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span><br>    &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> text[position];<br>    &#125;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[] (std::<span class="hljs-type">size_t</span> position) <br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)[position]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><code>const</code>帮助编译器侦测出错用法。</p></li></ul></li><li><p>确保对象使用前已经被初始化</p><ul><li>内置类型对象需要手工初始化，C++不保证初始化他它们。</li><li>构造函数最好使用成员初值列，而不是赋值操作，且其排列次序应与声明次序一致。</li><li>对于“跨编译单元初始化次序问题”，应以<code>local static</code>对象替换<code>non-local static</code>对象。</li></ul></li></ol><h1 id="构造、析构与赋值"><a href="#构造、析构与赋值" class="headerlink" title="构造、析构与赋值"></a>构造、析构与赋值</h1><ol><li><p>认真对待<code>default构造、copy构造、copy操作符及析构函数</code></p><ul><li><p>对于<code>指针、const</code>等特殊成员的操作需要自行定义。</p></li><li><p>对于需要阻止的操作，如<code>copy</code>， 可以选择将会自行生产的函数定义为<code>private</code>，但选择<code>empty base class optimization</code>继承是更好的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 符合empty base class optimization要求的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:<span class="hljs-comment">// 允许derived对象构造和析构</span><br>    <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br><span class="hljs-keyword">private</span>:<span class="hljs-comment">// 阻止复制</span><br>    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;);<br>    Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>为多态基类声明virtual析构函数】</p><ul><li><p><code>polimorphic（多态性的） base classes</code>应该声明一个virtual析构函数。</p></li><li><p>class带有任何virtual函数，它就应该拥有一个virtual析构函数。</p></li><li><p>对于抽象的class，使用<code>pure virtual</code>析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AWOV</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AWOV</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>classes的设计目的不是作为base classes使用的，就不应该声明virtual析构函数，请勿滥用virtual。</p></li></ul></li><li><p>不要在构造和析构过程中调用virtual函数</p><blockquote><p>构造和析构阶段的virtual调用不会下降到derived classes，应该使用传参的方式，将必要信息传递至base classes的构造函数中处理，同时对于调用的兄弟成员函数应该使用static保证预初始化。</p></blockquote></li><li><p>operator&#x3D;</p><ul><li><p>令<code>operator</code>返回一个<code>reference to *this</code>。</p></li><li><p>确保自我赋值的正确性，拥有异常安全性（函数操作多个对象，而多个对象其实是同一个对象时）。</p><blockquote><p>主要可以通过地址对比、语句顺序编排、copy-and-swap解决</p></blockquote></li><li><p>复制时，确保赋值对象的所有成员变量及base class成分（通常通过其copy函数实现）。</p></li><li><p>coping函数应注意消除重复代码，通常将相同的部分放入命名为init的函数供连个coping函数调用。</p></li></ul></li></ol><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><ol><li><p>以对象管理资源</p><ul><li><p>获得资源后立刻放进管理对象。</p></li><li><p>管理对象利用析构函数确保资源被释放。</p></li><li><p>智能指针<code>trl::auto_ptr</code>、<code>trl::shared_ptr</code>的使用。</p><blockquote><p>资源管理类的脊柱：<code>Resource Acquisition Is Initialization</code></p><p>auto_ptr在复制时会置源为null。保证指向唯一。</p></blockquote></li></ul></li><li><p>资源管理器</p><ol><li><p>小心coping行为：常见的方式为禁止复制和使用“引用计数法”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* pm)</span></span><br><span class="hljs-function">        : mutexPtr(pm, unlock)</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-built_in">lock</span>(mutexPtr.<span class="hljs-built_in">get</span>());<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;mutex&gt; mutexPtr;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p>提供对原始资源的访问</p></li></ol></li><li><p>成对使用<code>new</code>和<code>delete</code>且保证采取相同形式</p></li><li><p>以独立语句将<code>newed</code>对象置入智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br><span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>());<br><span class="hljs-comment">// 因为语句内的参数核算的次序具有不确定性，在生成对象并置入智能指针的过程中，掺杂其他操作，所以可能引起置入操作无法执行，从而造成内存泄漏。</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><ol><li><p>让接口容易被正确使用</p><ul><li>减少用户的需要操作的行为数，如手动delete等。</li><li>尽量保证接口一致性，以及与内置类型的行为兼容。</li><li>阻止误用的常见方法：建立新类型、束缚对象值、限制类型上的操作，以及消除用户的资源管理责任。</li></ul></li><li><p>设计class犹如设计type，需要思考以下问题：</p><ul><li>对象应该如何被创建和销毁？</li><li>对象的初始化和对象的赋值有什么样的差别？</li><li>对象被passed by value意味着什么？<code>copy构造函数是用来定义一个type的pass-by-value该如何实现的</code></li><li>新type的合法值是什么？</li><li>新type是否需要配合某个继承图系？</li><li>新type需要怎样的转换？</li><li>新type需要哪些函数？</li><li>谁该取用新type的成员？</li><li>什么是新type的“未声明接口”？</li><li>你的新type有多么一般化？<code>这个问题设计到是定义新class还是新class template</code></li><li>真的需要一个新type吗？</li></ul></li><li><p>在对待非内置；类型及STL的迭代器和函数对象时，用<code>pass-by-reference-to-const</code>替换<code>pass-by-value</code></p><blockquote><p>reference不仅可以省却构造函数和析构函数的效率成本，还可以避免切割（slicing）问题。但记住，对于内置类型、STL的迭代器和函数对象，pass-by-value往往更为高效，因为它们被生来被设计为此。</p></blockquote></li><li><p>必须返回对象时，别妄想返回其<code>reference</code>，绝不要返回指向<code>local stack</code>或<code>heap-allocated</code>对象的<code>reference</code>或<code>pointer</code></p></li><li><p>将成员变量声明为<code>private</code>（封装）</p><blockquote><p>这个问题可以从三个方面讨论：</p><ul><li>一致性问题：使用时不必为了思考是否加圆括号浪费时间。</li><li>权限控制与约束：通过函数对成员变量进行精确控制。</li><li>封装性：通过函数可以对用户异常获取变量的细节，提高弹性。</li></ul><p><code>protected</code>和<code>public</code>具有同样的问题–缺乏封装性，即其中的内容改变时，对用户的影响是不可测的，可能大量的代码需要重写、重测等。</p></blockquote></li><li><p>宁可使用<code>non-member</code>、<code>non-friend</code>函数替换<code>member</code>函数</p><blockquote><p>通常将相关函数分离出去，放置于同一个命名空间中，如此可以减少访问private成员的途径数，增加了封装性、包裹弹性和机能扩充性。</p></blockquote></li><li><p>若所有参数（包括被this指针所指的隐喻参数）皆需要类型转换，请为此采用<code>non-member</code>函数</p></li><li><p>写出一个不抛异常且高效的<code>swap</code>函数</p><blockquote><p>遵循一下步骤去实现：</p><ul><li>当<code>std::swap</code>对你的类型效率不高时，提供一个swap成员函数，并确定该函数不抛出异常。</li><li>提供一个non-member swap来调用成员swap函数，对于classes，请同时特化<code>std::swap</code>。</li><li>调用swap时，应使用<code>using std::swap</code>声明式，然后不带任何命名空间修饰地调用swap。</li><li>为用户自定义类型进行std templates全特化是好的，但别向std内加入新东西！</li></ul></blockquote></li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li><p>尽可能延后变量定义式的出现时间</p></li><li><p>尽量少做转型动作，避免<code>dynamic_casts</code>，如若必须，尽量使用C++style转型。</p></li><li><p>避免返回handles（ref、指针、迭代器）指向对象内部成分</p><blockquote><p>究其原因，传出handles使得其被暴露在了比其所指向对象更长寿的风险中，但这并不意味着一定不可向外传播handle。</p></blockquote></li><li><p>为“异常安全”而努力是值得的</p><blockquote><p>异常安全函数：1. 不泄漏任何资源； 2. 不败坏任何数据。</p><p>异常安全函数的三个保证级别：</p><ul><li>基本承诺：所有对象处于内部前后一致的状态，然而程序的现实状态可能不可预料。</li><li>强烈保证：如果异常抛出，则执行回滚，程序状态不改变。</li><li>不抛掷保证：作用于内置类型的所有操作都提供no-throw保证。</li></ul><p>函数提供的“异常安全”通常等于其所调用的各个函数的最弱者。</p></blockquote></li><li><p>留心inlining的使用</p><blockquote><p>遵循两个原则：</p><ul><li>将inline限制在小型、被频繁调用的函数。</li><li>找到关键（主要耗时）代码进行瘦身。</li></ul><p>记住，inline会使得程序的调试和二进制升级变得困难，同时伴随潜在的代码膨胀问题。</p></blockquote></li><li><p><strong>将文件间的编译依存关系降至最低</strong></p><blockquote><p>遵循两个原则：</p><ul><li>相依与声明式，而不是定义式：Handle classes和Interface classes</li><li>程序库头文件应该“完全且仅有声明式”</li></ul></blockquote></li></ol><h1 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h1><ol><li><p>用is-a去塑造public继承</p></li><li><p>避免遮掩继承而来的名称</p><blockquote><p>采取的措施：</p><ul><li>使用using声明式</li><li>使用转交函数（inline）</li></ul></blockquote></li><li><p>区分接口继承和实现继承</p></li><li><p>考虑virtual函数以外的其他选择</p><ul><li>Template Method设计模式：<ul><li>non-virtual interface(NVI)：以public non-virtual函数包裹较低访问性的private或protected的virtual函数</li></ul></li><li>Strategy设计模式<ul><li>以函数指针成员变量替换virtual函数</li><li>以trl::function成员变量替换virtual函数</li><li>不同体系的virtual函数替换</li></ul></li></ul></li><li><p>绝不重新定义继承而来的non-virtual函数</p></li><li><p>绝不重新定义继承而来的缺省参数值，缺省参数是静态绑定的</p></li><li><p>根据复合塑模出has-a或根据某物实现出</p></li><li><p>明智而审慎地使用private继承</p><blockquote><p>使用场景：</p><ul><li>根据基类的东西实现出时</li><li>为了追求empty-base-optimization（空白基类最优化）时</li></ul></blockquote></li><li><p>明智而审慎地使用多重继承</p><blockquote><p>多重继承会带来歧义、维护等复杂问题，在考虑牺牲空间和速度的情况下，可以采用virtual继承进行“优化”，不能否定多重继承有其独特的应用领域。</p></blockquote></li></ol><h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><ol><li><p>辨识隐式接口和编译期多态</p><blockquote><p>template提供区别于classes的隐式接口，和区别与virtual函数的编译期多态。</p></blockquote></li><li><p>了解typename的双重意义</p><blockquote><ul><li>前缀关键词class和typername可互换。</li><li>使用typename 标识嵌套从属类型名称，但不能在基类列和成员初始列内作为base class修饰符。</li></ul></blockquote></li><li><p>正确处理模板化基类内的名称</p><blockquote><p>多重模板继承会出现烦人的编译错误，可以通过<code>this-&gt;</code>或<code>base class</code>资格修饰符完成调用。</p></blockquote></li><li><p>将于参数无关的代码抽离templates</p><blockquote><p>思维工具：共性与变性分析。</p><p>代码膨胀的主要原因：类型参数的无复用和非类型参数不适当造成。</p><p>解决方式：</p><ul><li>非类型参数：函数参数和成员变量替换。</li><li>类型参数：带有相同二进制表述的具现类型共享实现码。</li></ul></blockquote></li><li><p>运用成员函数模板接受所有兼容类型</p><blockquote><ul><li>使用member function templates生产兼容（泛化）函数。</li><li>在泛化构造函数或赋值操作时，需要声明正常的相关函数。</li></ul></blockquote></li><li><p>需要类型转换时请为模板定义非成员函数</p></li><li><p>使用traits classes表现类型信息</p><blockquote><p>结合重载技术后，<code>traits classes</code>能在编译期对类型执行<code>if...else</code>测试。</p></blockquote></li><li><p>template元编程</p><blockquote><p>元编程优势：</p><ul><li>将工作由运行期移至编译期，实现早期错误侦测和更高的执行效率。</li><li>可以实现“基于政策选择组合”的定制代码，实现运行期不可能实现的操作。</li></ul></blockquote></li></ol><h1 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h1><ol><li>new-handler</li><li>new和delete的合理替换</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书籍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程经验与规范</title>
    <link href="/2022/06/12/GO/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/06/12/GO/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="功能选项模式"><a href="#功能选项模式" class="headerlink" title="功能选项模式"></a>功能选项模式</h3><p>通过opt自定义参数，进行生成模板的修改，从而实现部件自定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Client rpc client based on net/rpc implementation</span><br><span class="hljs-keyword">type</span> Client <span class="hljs-keyword">struct</span> &#123;<br>*rpc.Client<br>&#125;<br><br><span class="hljs-comment">//Option provides options for rpc</span><br><span class="hljs-keyword">type</span> Option <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *options)</span></span><br><br><span class="hljs-keyword">type</span> options <span class="hljs-keyword">struct</span> &#123;<br>compressType compressor.CompressType<br>serializer   serializer.Serializer<br>&#125;<br><br><span class="hljs-comment">// WithCompress set client compression format</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithCompress</span><span class="hljs-params">(c compressor.CompressType)</span></span> Option &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *options)</span></span> &#123;<br>o.compressType = c<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// WithSerializer set client serializer</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithSerializer</span><span class="hljs-params">(serializer serializer.Serializer)</span></span> Option &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(o *options)</span></span> &#123;<br>o.serializer = serializer<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// NewClient Create a new rpc client</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">(conn io.ReadWriteCloser, opts ...Option)</span></span> *Client &#123;<br>options := options&#123;<br>compressType: compressor.Raw,<br>serializer:   serializer.Proto,<br>&#125;<br><span class="hljs-keyword">for</span> _, option := <span class="hljs-keyword">range</span> opts &#123;<br>option(&amp;options)<br>&#125;<br><span class="hljs-keyword">return</span> &amp;Client&#123;rpc.NewClientWithCodec(<br>codec.NewClientCodec(conn, options.compressType, options.serializer))&#125;<br>&#125;<br><br><span class="hljs-comment">// Call synchronously calls the rpc function</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> Call(serviceMethod <span class="hljs-type">string</span>, args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> c.Client.Call(serviceMethod, args, reply)<br>&#125;<br><br><span class="hljs-comment">// AsyncCall asynchronously calls the rpc function and returns a channel of *rpc.Call</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> AsyncCall(serviceMethod <span class="hljs-type">string</span>, args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-keyword">chan</span> *rpc.Call &#123;<br><span class="hljs-keyword">return</span> c.Go(serviceMethod, args, reply, <span class="hljs-literal">nil</span>).Done<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h1><p>REST(Representational State Transfer :表述性状态转化)指满足一组架构约束条件和原则一个架构样式的网络系统 ,比如 web 应用程序。而这样的设计称为Restful。</p><p>主要概念：</p><ol><li>资源(Resources)</li><li>表现层（Representation）</li><li>状态转化（State Transfer）</li></ol><p>通俗讲，Restful是以资源标识、层级划分、状态定义进行接口的设计方法，如GET、POST等动词不应出现在URL中，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs api">/bank/account?id=1   GET <br></code></pre></td></tr></table></figure><h1 id="优化设计"><a href="#优化设计" class="headerlink" title="优化设计"></a>优化设计</h1><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><p><strong>实现要求：</strong>不同层之间对外的接口一律以interface的方式提供，并且单一职责的设计，接口尽可能简单清晰，接口文件单独存放，不放在具体实现的文件中，依赖参数定义和接口声明放在一起。</p><p>示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>BAD：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>  Conf *Config <span class="hljs-comment">// 依赖 Config</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">()</span></span> *Server &#123;<br>  <span class="hljs-keyword">return</span> &amp;&#123;<br>    Conf: config.New()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>GOOD：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>  Conf *Config <span class="hljs-comment">// 依赖 Config</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(c *Config)</span></span> *Server &#123;<span class="hljs-comment">//依赖以参数的方式进行注入模块中</span><br>  <span class="hljs-keyword">return</span> &amp;&#123;<br>    Conf: c<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h1><p>推荐阅读：<a href="https://github.com/xxjwxc/uber_go_guide_cn">Uber Go 语言编码规范中文版. The Uber Go Style Guide .</a></p>]]></content>
    
    
    <categories>
      
      <category>GO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
